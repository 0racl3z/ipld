# Convenience IPLD types
The types described in the schemas below are not referenced directly from within the canonical Ethereum merkle tree.
Instead, these types can be constructed and verified from their underlying canonical Ethereum IPLD structures using the algorithms described by their
ADLs. These types are introduced to improve the convenience and performance of accessing and working with the canonical Ethereum IPLD objects
for certain purposes.

## Transaction Trace IPLD
Transaction traces contain the EVM context, input, and output for each individual OPCODE operation performed during the application of a transaction on a certain state.
We would like to be able to reference these TxTrace objects by the corresponding transaction multihash
* We need to reference by more than just txhash since the same tx can produce different traces when applied to different initial state
    * We need a new multicodec type than we can combine with the corresponding transaction multihash, the tx index, and the state root multihash for the block the transactions are applied on top of
    * Referencing in this manner is not a proper content hash reference since the multihash is not the hash of the `TxTrace` content that is being referenced

```ipldsch
# TxTrace contains the EVM context, input, and output for each OPCODE in a transaction
# The problem is, we want to be able to reference to this from the corresponding transaction's multihash by simply
# combining it with a different multicodec, but that would mean the multihash is not the hash of the TxTrace content but
# rather of the corresponding transaction- which breaks IPLD convention.
type TxTrace struct {
    Result Bytes
    Frames [Frame]
    Gas Uint
    Failed Bool
}

# Frame represents the EVM context, input, and output for a specific OPCODE during a transaction trace
type Frame struct {
    Op     OpCode
    From   Address
    To     Address
    Input  Bytes
    Output Bytes
    Gas    Uint
    Cost   Uint
    Value  BigInt
}
```

## Block IPLD
`Block` IPLD represents an entire block in the Ethereum blockchain, it contains direct content hash references to
the RLP encoded sets of transactions and receipts for that block in order to avoid the need to traverse the transaction
and receipt tries to collect these sets (as is required when starting from a canonical `Header` block).
We want to be able to reference to this from the corresponding header's multihash by simply combining that multihash with a different
multicodec, but doing so will break IPLD convention as the multihash is not the content hash of the `Block` being referenced.
```ipldsch
# Block represents an entire block in the Ethereum blockchain.
type Block struct {
    Header       &Header
    Uncles       &Uncles
    Transactions &Transactions
    Receipts     &Receipts
}
```

## Transactions IPLD
The `Transactions` IPLD represents the entire ordered list of transactions for a given block. It is referenced by the KECCAK_256 hash of the 
RLP encoded list. This forms a proper IPLD object, but its content hash is not referenced from within any canonical Ethereum object.
Instead, it is referenced from the above proposed `Block` object.
```ipldsch
# Transactions contains a list of references to Ethereum transactions
# It is referenced by the KECCAK-256 hash of the RLP encoded list of transactions
# This would be analogous to how uncles are linked from the header
type Transactions [&Transaction]
```

## Receipts IPLD
The `Receipts` IPLD represents the entire ordered list of receipts for a given block. It is referenced by the KECCAK_256 hash of the
RLP encoded list. This forms a proper IPLD object, but its content hash is not referenced from within any canonical Ethereum object.
Instead, it is referenced from the above proposed `Block` object.
```ipldsch
# Receipts contains a list of references to Ethereum receipts
# It is referenced by the KECCAK-256 hash of the RLP encoded list of receipts
# This would be analogous to how uncles are linked fromm the header
type Receipts [&Receipt]
```

## Genesis IPLD
This is a single IPLD block at the base of the entire chain with this layout. It is
encoded with DAG-CBOR with a KECCAK-256 which gives the CID:
`to-be-added`.

This IPLD block is not referenced as height `0` as this is reserved for the first
`Header` block which carries the initial state. The `Header` block at height `0` (genesis block) references the
corresponding `GenesisInfo` from which it was generated by its `ParentHash`/`ParentReference`. Since Ethereum was
created without the IPLD format in mind, the canonical genesis block contains an "empty" `ParentHash` of `0x0000000000000000000000000000000000000000000000000000000000000000`
which is not a multihash of the `GenesisInfo` used to create it. In order to convert this into a link to the `GenesisInfo`
we need to break some conventions.

There are three possible ways of addressing this issue:
1) Define new multicodec types for each `GenesisInfo` variant which we combine with the `0x0000000000000000000000000000000000000000000000000000000000000000` multihash
   to create a reference to that specific `GenesisInfo`.
    * This breaks IPLD convention due to the multihash no longer being a hash of the referenced content
    * We need different multicodecs for each `GenesisInfo` variant
2) Define a single new multicodec type for the `GenesisInfo` type and include inside the genesis block IPLD `ParentReference` a true content hash reference to the corresponding `GenesisInfo`,
   with the caveat that when hashing the genesis block IPLD to generate references to it (when generating its blockhash) we first replace the `ParentReference` content hash with the expected `0x0000000000000000000000000000000000000000000000000000000000000000`.
    * This breaks IPLD convention for the `ParentReference` from the header at height `1` to the genesis block since that content hash will be of the canonical Ethereum genesis block containing `0x0000000000000000000000000000000000000000000000000000000000000000`
      and not of the IPLD block which actually contains the `GenesisInfo` content hash
3) Avoid requiring a link from the genesis block to the `GenesisInfo`, `GenesisInfo` content hashes can instead be thought of as constants that are expected to be known without reference from the genesis block.

```ipldsch
# GenesisInfo specifies the header fields, state of a genesis block, and hard fork switch-over blocks through the chain configuration.
# NOTE: we need a new multicodec type for the Genesis object
type GenesisInfo struct {
    Config     ChainConfig
    Nonce      Uint
    Timestamp  Uint
    ExtraData  Bytes
    GasLimit   Unit
    Difficulty BigInt
    Mixhash    Hash
    Coinbase   Address
    Alloc      GenesisAlloc
    
    # These fields are used for consensus tests. Please don't use them
    # in actual genesis blocks.
    Number     Uint
    GasUsed    Uint
    ParentHash Hash
}

# GenesisAlloc is a map that specifies the initial state that is part of the genesis block.
type GenesisAlloc {Address:GenesisAccount}

# GenesisAccount is an account in the state of the genesis block.
type GenesisAccount struct {
    Code       Bytes
    Storage    {Hash:Hash}
    Balance    BigInt
    Nonce      Uint
    PrivateKey Bytes
}

# ChainConfig is the core config which determines the blockchain settings.
# ChainConfig is stored in the database on a per block basis. This means
# that any network, identified by its genesis block, can have its own
# set of configuration options.
type ChainConfig struct {
    ChainID BigInt
    HomesteadBlock BigInt
    DAOForkBlock   BigInt
    DAOForkSupport Bool
    EIP150Block BigInt
    EIP150Hash  Hash
    EIP155Block BigInt
    EIP158Block BigInt
    ByzantiumBlock      BigInt
    ConstantinopleBlock BigInt
    PetersburgBlock     BigInt
    IstanbulBlock       BigInt
    MuirGlacierBlock    BigInt
    YoloV2Block BigInt
    EWASMBlock  BigInt
	
    # Various consensus engines
    Ethash EthashConfig
    Clique CliqueConfig
}

# EthashConfig is the consensus engine config for proof-of-work based sealing.
type EthashConfig struct {} representation tuple

# CliqueConfig is the consensus engine config for proof-of-authority based sealing.
type CliqueConfig struct {
    Period Uint
    Epoch Uint
}
```