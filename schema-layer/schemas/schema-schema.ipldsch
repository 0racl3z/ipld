## -----
## This is the schema describing the schema declarations for IPLD Schemas.
## Yes, it's self-describing! :)
## -----

## Type names are a simple alias of string.
##
## There are some additional rules that should be applied:
##   - Type names should by convention begin with a capital letter;
##   - Type names must be all printable characters (no whitespace);
##   - Type names must not contain punctuation (dashes, dots, etc).
##
## Type names are strings meant for human consumption at a local scope.
## When making a Schema, note that the TypeName is the key of the map:
## a TypeName must be unique within the Schema.
##
type TypeName string

## SchemaMap is a complete set of types;
## it is simply a map of TypeName to detailed declaration of that Type.
##
## A simple schema map with one type might look like this:
##
## ```
## {
##   "MyFooType": {
##     "type": "string"
##   }
## }
## ```
##
type SchemaMap map {TypeName:Type}

## Schema is a single-member union, which can be used in serialization
## to make a form of "nominative type declaration".
##
## A complete (if quite short) Schema might look like this:
##
## ```
## {
##   "schema": {
##     "MyFooType": {
##       "type": "string"
##     }
##   }
## }
## ```
##
type Schema union {
	| SchemaMap "schema"
} representation keyed

## The types of Type are a union.
##
## The Type union is serialized using "inline" union representation,
## which means all of its members have map representations, and there will be
## an entry in that map called "type" which contains the union discriminator.
##
## Some of the kinds of type are so simple the union discriminator is the only
## content at all, e.g. strings:
##
## ```
## {
##   "type": "string"
## }
## ```
##
## Other types have more content.  Consider this example of a map type:
##
## ```
## {
##   "type": "map",
##   "keyType": "String",
##   "valueType": "Int"
## }
## ```
##
type Type union {
	| TypeBool "bool"
	| TypeString "string"
	| TypeBytes "bytes"
	| TypeInt "int"
	| TypeFloat "float"
	| TypeMap "map"
	| TypeList "list"
	| TypeLink "link"
	| TypeUnion "union"
	| TypeStruct "struct"
	| TypeEnum "enum"
} representation inline "kind"

## TypeKind enumerates all the major kinds of type.
## Notice this enum's members are the same as the set of strings used as
## discriminants in the Type union.
##
## TODO: not actually sure we'll need to declare this.  Only usage is
## in the Type union representation details?
type TypeKind enum {
	| "bool"
	| "string"
	| "bytes"
	| "int"
	| "float"
	| "map"
	| "list"
	| "link"
	| "union"
	| "struct"
	| "enum"
}

## RepresentationKind is similar to TypeKind, but includes only those concepts
## which exist at the IPLD *Data Model* level.
##
## In other words, structs, unions, and enumerations are not present:
## those concepts are introduced in the IPLD Schema system, and when serialized,
## all of them must be transformable to one of these representation kinds
## (e.g. a "struct" TypeKind will usually be transformed to a "map"
## RepresentationKind; "enum" TypeKind are always "string" RepresentationKind;
## and so on.)
##
## RepresentationKind strings are sometimes used to to indicate part of the
## definition in the details of Type; for example, they're used describing
## some of the detailed behaviors of a "kinded"-style union type.
type RepresentationKind enum {
	| "bool"
	| "string"
	| "bytes"
	| "int"
	| "float"
	| "map"
	| "list"
	| "link"
}

## TypeBool describes a simple boolean type.
## It has no details.
##
type TypeBool struct {}

## TypeString describes a simple string type.
## It has no details.
##
type TypeString struct {}

## TypeBytes describes a simple byte array type.
## It has no details.
##
type TypeBytes struct {}

## TypeInt describes a simple integer numeric type.
## It has no details.
##
type TypeInt struct {}

## TypeFloat describes a simple floating point numeric type.
## It has no details.
##
type TypeFloat struct {}

## TypeMap describes a key-value map.
## The keys and values of the map have some specific type of their own.
##
type TypeMap struct {
	keyType TypeName # additionally, the referenced type must be reprkind==string.
	valueType TypeTerm
}

## TypeList describes a list.
## The values of the list have some specific type of their own.
##
type TypeList struct {
	valueType TypeTerm
}

## TypeLink describes a hash linking to another object (a CID).
##
## REVIEW: this currently has no details... but possibly it should have a
## type hint for what we expect when resolving the link?
##
type TypeLink struct {}

## TypeUnion describes a union (sometimes called a "sum type", or
## more verbosely, a "discriminated union").
## A union is a type that can have a value of several different types, but
## unlike maps or structs, in a union only one of those values may be present
## at a time.
##
## Unions can be defined as representing in several different ways: see
## the documentation on the UnionRepresentation type for details.
##
## The set of types which the union can contain are specified in a map
## inside the representation field.  (The key type of the map varies per
## representation strategy, so it's not possible to keep on this type directly.)
##
type TypeUnion struct {
	representation UnionRepresentation
}

## UnionRepresentation is a union of all the distinct ways a TypeUnion's values
## can be mapped onto a serialized format for the IPLD Data Model.
##
## There are "keyed", "envelop", and "inline" strategies, which are all ways
## to produce representations in a map format (some literature may describe
## this as "tagged" style unions), and a fourth style, "kinded" unions, may
## actually encode itself as any of the other representation kinds!
##
## Note: Unions can be used to produce a "nominative" style of type declarations
## -- yes, even given that IPLD Schema systems are natively "structural" typing!
##
type UnionRepresentation union {
	| UnionRepresentation_Kinded "kinded"
	| UnionRepresentation_Keyed "keyed"
	| UnionRepresentation_Envelope "envelope"
	| UnionRepresentation_Inline "inline"
} representation keyed

## "Kinded" union representations describe a bidirectional mapping between
## a RepresentationKind and a Type (referenced by name) which should be the
## union member decoded when one sees this RepresentationKind.
##
## The referenced type must of course produce the RepresentationKind it's
## matched with!
type UnionRepresentation_Kinded map {RepresentationKind:TypeName}

## "Keyed" union representations will encode as a map, where the map has
## exactly one entry, the key string of which will be used to look up the name
## of the Type; and the value should be the content, and be of that Type.
##
## Note: when writing a new protocol, it may be wise to prefer keyed unions
## over the other styles wherever possible; keyed unions tend to have good
## performance characteristics, as they have most "mechanical sympathy" with
## parsing and deserialization implementation order.
type UnionRepresentation_Keyed map {String:TypeName}

## "Envelope" union representations will encode as a map, where the map has
## exactly two entries: the two keys should be of the exact strings specified
## for this envelope representation.  The value for the discriminator key
## should be one of the strings in the discriminant table.  The value for
## the content key should be the content, and be of the Type matching the
## lookup in the discriminant table.
type UnionRepresentation_Envelope struct {
	discriminatorKey String
	contentKey String
	discriminantTable {String:TypeName}
}

## "Inline" union representations require that all of their members encode
## as a map, and encode their type info into the same map as the member data.
## Thus, the map for an inline union may have any number of entries: it is
## however many fields the member value has, plus one (for the discriminant).
##
## All members of an inline union must be struct types and must encode to
## the map RepresentationKind.  Other types which encode to map (such as map
## types themselves!) cannot be used: the potential for content values with
## with keys overlapping with the discriminatorKey would result in undefined
## behavior!  Similarly, the member struct types may not have fields which
## have names that collide with the discriminatorKey.
##
## When designing a new protocol, use inline unions sparringly; despite
## appearing simple, they have the most edge cases of any kind of union
## representation, and their implementation is generally the most complex and
## is difficult to optimize deserialization to support.
type UnionRepresentation_Inline struct {
	discriminatorKey String
	discriminantTable {String:TypeName}
}

## TypeStruct describes a type which has a group of fields of varying Type.
## Each field has a name (and typically, the struct will be represented as a
## map, which uses these names as the map keys).
type TypeStruct struct {
	fields {String:StructField}
	representation StructRepresentation
}

type StructField struct {
	content TypeTerm
	optional Bool
}

type TypeTerm = TODO

type StructRepresentation union {
	| StructRepresentation_Map "map"
	| StructRepresentation_Tuple "tuple"
}
type StructRepresentation_Map struct {
	fieldAliases optional {String:String}
}
type StructRepresentation_Tuple struct {
	fieldOrder optional [String]
}

## TypeEnum describes a type which has a known, pre-defined set of possible
## values.  Each of the values must be representable a string.
type TypeEnum struct {
	members {String:Null}
}
